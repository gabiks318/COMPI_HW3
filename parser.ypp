%{
    #include <stdio.h>
    #include "hw3_output.hpp"
    #include "types.h"
    #include "symbol_table.h"

    extern int yylineno;
    extern int yylex();
    int yyerror(const char* message);

     using namespace output;
%}

    %token VOID INT BYTE B BOOL CONST TRUE FALSE IF RETURN WHILE BREAK CONTINUE SC COMMA COMMENT ID NUM STRING AUTO


    %right ASSIGN

    %left OR
    %left AND
    %left RELOP
    %left ADD_SUB
    %left MULT_DIV
	%right NOT
    %left LPAREN RPAREN LBRACE RBRACE
    %right ELSE

%%
Program: Funcs                                                      {printProductionRule(1);}

Funcs: /*epsilon*/                                                  {printProductionRule(2);}
       | FuncDecl Funcs                                             {printProductionRule(3);}

FuncDecl: RetType ID LPAREN Formals RPAREN LBRACE OS Statements ES RBRACE {printProductionRule(4);}

RetType: Type                                                       {printProductionRule(5);}
         | VOID                                                     {printProductionRule(6);}

Formals: /*epsilon*/                                                {printProductionRule(7);}
         | FormalsList                                              {printProductionRule(8);}

FormalsList: FormalDecl                                             {printProductionRule(9);}
             | FormalDecl COMMA FormalsList                         {printProductionRule(10);}

FormalDecl:  Type ID                                                {printProductionRule(11);}

Statements: Statement                                               {$$ = new Statements(dynamic_cast<Statement*>($1));}
            | Statements Statement                                  {$$ = new Statements(dynamic_cast<Statements*>($1), dynamic_cast<Statement*>($2));}

Statement: LBRACE OS Statements ES RBRACE                           {printProductionRule(14);}
           | Type ID SC                                             {$$ = new Statement(dynamic_cast<Type*>($1), $2);}
           | Type ID ASSIGN Exp SC                                  {$$ = new Statement(dynamic_cast<Type*>($1), $2), dynamic_cast<Exp*>($3);}
           | AUTO ID ASSIGN Exp SC                                  {$$ = new Statement(nullptr, $2), dynamic_cast<Exp*>($3);}
           | ID ASSIGN Exp SC                                       {$$ = new Statement($1, dynamic_cast<Exp*>($3));}
           | Call SC                                                {$$ = new Statement(dynamic_cast<Call*>($1));}
           | RETURN SC                                              {printProductionRule(20);}
           | RETURN Exp SC                                          {printProductionRule(21);}
           | IF LPAREN Exp RPAREN OS Statement ES                   {$$ = new Statement(dynamic_cast<Exp*>($3));}
           | IF LPAREN Exp RPAREN OS Statement ES OS ELSE ES Statement   {$$ = new Statement(dynamic_cast<Exp*>($3));}
           | WHILE LPAREN Exp RPAREN OS Statement ES                {$$ = new Statement(dynamic_cast<Exp*>($3));}
           | BREAK SC                                               {printProductionRule(25);}
           | CONTINUE SC                                            {printProductionRule(26);}

Call: ID LPAREN ExpList RPAREN                                      {$$ = new Call($1, $3);}
      | ID LPAREN RPAREN                                            {$$ = new Call($1);}

ExpList: Exp                                                        {$$ = new ExpList($1);}
         | Exp COMMA ExpList                                        {$$ = new ExpList($2, $1);}

Type: INT                                                           {printProductionRule(31);}
      | BYTE                                                        {printProductionRule(32);}
      | BOOL                                                        {printProductionRule(33);}

Exp: LPAREN Exp RPAREN                                              {$$ = new Exp(dynamic_cast<Exp*>($2));}
     | Exp ADD_SUB Exp                                              {$$ = new Exp($1, $3, $2->value, "int");}
     | Exp MULT_DIV Exp                                             {$$ = new Exp($1, $3, $2->value, "int");}
     | ID                                                           {$$ = new Exp($1);}
     | Call                                                         {$$ = new Exp($1);}
     | NUM                                                          {$$ = new Exp($1, "int");}
     | NUM B                                                        {$$ = new Exp($1, "byte");}
     | STRING                                                       {$$ = new Exp($1, "string");}
     | TRUE                                                         {$$ = new Exp($1, "bool");}
     | FALSE                                                        {$$ = new Exp($1, "bool");}
     | NOT Exp                                                      {$$ = new Exp($2, $2, $1->value, "bool");}
     | Exp AND Exp                                                  {$$ = new Exp($1, $3, $2->value, "bool");}
     | Exp OR Exp                                                   {$$ = new Exp($1, $3, $2->value, "bool");}
     | Exp RELOP Exp                                                {$$ = new Exp($1, $3, $2->value, "relop");}
     | LPAREN Type RPAREN Exp                                       {$$ = new Exp($4, $2);}

OS:                                                                 {tables.push_scope();}
ES:                                                                 {tables.pop_scope();}
%%

int main(){
        return yyparse();
}

int yyerror(const char * message){
	errorSyn(yylineno);
	exit(0);
}